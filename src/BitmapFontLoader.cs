using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;

// AngelCode bitmap font parsing using C#
// https://www.cyotek.com/blog/angelcode-bitmap-font-parsing-using-csharp

// Copyright Â© 2012-2020 Cyotek Ltd.

// This work is licensed under the MIT License.
// See LICENSE.TXT for the full text

// Found this code useful?
// https://www.paypal.me/cyotek

namespace Cyotek.Drawing.BitmapFont
{
  /// <summary>
  /// Parsing class for bitmap fonts generated by AngelCode BMFont
  /// </summary>
  public static class BitmapFontLoader
  {
    #region Public Methods

    public static BitmapFont LoadFontFromBinaryFile(string fileName)
    {
      BitmapFont font;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException(nameof(fileName));
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }

      font = new BitmapFont();

      using (Stream stream = File.OpenRead(fileName))
      {
        font.LoadBinary(stream);
      }

      QualifyResourcePaths(font, Path.GetDirectoryName(fileName));

      return font;
    }

    /// <summary>
    /// Loads a bitmap font from a file, attempting to auto detect the file type
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <exception cref="FileNotFoundException">Thrown when the requested file is not present.</exception>
    /// <exception cref="InvalidDataException">Thrown when an Invalid Data error condition occurs.</exception>
    /// <param name="fileName">Name of the file to load.</param>
    /// <returns>
    /// A <see cref="BitmapFont"/> containing the loaded data.
    /// </returns>
    public static BitmapFont LoadFontFromFile(string fileName)
    {
      BitmapFont result;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException(nameof(fileName), "File name not specified");
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }

      switch (BitmapFontLoader.GetFileFormat(fileName))
      {
        case BitmapFontFormat.Binary:
          result = BitmapFontLoader.LoadFontFromBinaryFile(fileName);
          break;

        case BitmapFontFormat.Text:
          result = BitmapFontLoader.LoadFontFromTextFile(fileName);
          break;

        case BitmapFontFormat.Xml:
          result = BitmapFontLoader.LoadFontFromXmlFile(fileName);
          break;

        default:
          throw new InvalidDataException("Unknown file format.");
      }

      return result;
    }

    /// <summary>
    /// Loads a bitmap font from a file containing font data in text format.
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <exception cref="FileNotFoundException">Thrown when the requested file is not present.</exception>
    /// <param name="fileName">Name of the file to load.</param>
    /// <returns>
    /// A <see cref="BitmapFont"/> containing the loaded data.
    /// </returns>
    public static BitmapFont LoadFontFromTextFile(string fileName)
    {
      BitmapFont font;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException(nameof(fileName));
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }

      font = new BitmapFont();

      using (Stream stream = File.OpenRead(fileName))
      {
        font.LoadText(stream);
      }

      QualifyResourcePaths(font, Path.GetDirectoryName(fileName));

      return font;
    }

    /// <summary>
    /// Loads a bitmap font from a file containing font data in XML format.
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <exception cref="FileNotFoundException">Thrown when the requested file is not present.</exception>
    /// <param name="fileName">Name of the file to load.</param>
    /// <returns>
    /// A <see cref="BitmapFont"/> containing the loaded data.
    /// </returns>
    public static BitmapFont LoadFontFromXmlFile(string fileName)
    {
      BitmapFont font;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException(nameof(fileName));
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }

      font = new BitmapFont();

      using (Stream stream = File.OpenRead(fileName))
      {
        font.LoadXml(stream);
      }

      QualifyResourcePaths(font, Path.GetDirectoryName(fileName));

      return font;
    }

    #endregion Public Methods

    #region Internal Methods

    internal static BitmapFontFormat GetFileFormat(string fileName)
    {
      using (Stream stream = File.OpenRead(fileName))
      {
        return BitmapFontLoader.GetFileFormat(stream);
      }
    }

    internal static BitmapFontFormat GetFileFormat(Stream stream)
    {
      BitmapFontFormat result;
      byte[] buffer;
      long position;

      position = stream.Position;
      buffer = new byte[5];

      stream.Read(buffer, 0, 5);

      stream.Position = position;

      if (buffer[0] == 66 && buffer[1] == 77 && buffer[2] == 70 && buffer[3] == 3)
      {
        result = BitmapFontFormat.Binary;
      }
      else if (buffer[0] == 105 && buffer[1] == 110 && buffer[2] == 102 && buffer[3] == 111 && buffer[4] == 32)
      {
        result = BitmapFontFormat.Text;
      }
      else if (buffer[0] == 60 && buffer[1] == 63 && buffer[2] == 120 && buffer[3] == 109 && buffer[4] == 108)
      {
        result = BitmapFontFormat.Xml;
      }
      else
      {
        result = BitmapFontFormat.None;
      }

      return result;
    }

    /// <summary>
    /// Returns a boolean from an array of name/value pairs.
    /// </summary>
    /// <param name="parts">The array of parts.</param>
    /// <param name="name">The name of the value to return.</param>
    /// <param name="defaultValue">Default value(if the key doesnt exist or can't be parsed)</param>
    /// <returns></returns>
    internal static bool GetNamedBool(string[] parts, string name, bool defaultValue = false)
    {
      string s = GetNamedString(parts, name);

      bool result;
      int v;
      if (int.TryParse(s, out v))
      {
        result = v > 0;
      }
      else
      {
        result = defaultValue;
      }

      return result;
    }

    /// <summary>
    /// Returns an integer from an array of name/value pairs.
    /// </summary>
    /// <param name="parts">The array of parts.</param>
    /// <param name="name">The name of the value to return.</param>
    /// <param name="defaultValue">Default value(if the key doesnt exist or can't be parsed)</param>
    /// <returns></returns>
    internal static int GetNamedInt(string[] parts, string name, int defaultValue = 0)
    {
      string s = GetNamedString(parts, name);

      int result;
      if (!int.TryParse(s, out result))
      {
        result = defaultValue;
      }

      return result;
    }

    /// <summary>
    /// Returns a string from an array of name/value pairs.
    /// </summary>
    /// <param name="parts">The array of parts.</param>
    /// <param name="name">The name of the value to return.</param>
    /// <returns></returns>
    internal static string GetNamedString(string[] parts, string name)
    {
      string result;

      result = string.Empty;

      foreach (string part in parts)
      {
        int nameEndIndex;

        nameEndIndex = part.IndexOf('=');
        if (nameEndIndex != -1)
        {
          string namePart;
          string valuePart;

          namePart = part.Substring(0, nameEndIndex);
          valuePart = part.Substring(nameEndIndex + 1);

          if (string.Equals(name, namePart, StringComparison.OrdinalIgnoreCase))
          {
            int length;

            length = valuePart.Length;

            if (length > 1 && valuePart[0] == '"' && valuePart[length - 1] == '"')
            {
              valuePart = valuePart.Substring(1, length - 2);
            }

            result = valuePart;
            break;
          }
        }
      }

      return result;
    }

    /// <summary>
    /// Creates a Padding object from a string representation
    /// </summary>
    /// <param name="s">The string.</param>
    /// <returns></returns>
    internal static Padding ParsePadding(string s)
    {
      string[] parts;

      parts = s.Split(',');

      return new Padding()
      {
        Left = Convert.ToInt32(parts[3].Trim()),
        Top = Convert.ToInt32(parts[0].Trim()),
        Right = Convert.ToInt32(parts[1].Trim()),
        Bottom = Convert.ToInt32(parts[2].Trim())
      };
    }

    /// <summary>
    /// Creates a Point object from a string representation
    /// </summary>
    /// <param name="s">The string.</param>
    /// <returns></returns>
    internal static Point ParsePoint(string s)
    {
      string[] parts;

      parts = s.Split(',');

      return new Point()
      {
        X = Convert.ToInt32(parts[0].Trim()),
        Y = Convert.ToInt32(parts[1].Trim())
      };
    }

    /// <summary>
    /// Updates <see cref="Page"/> data with a fully qualified path
    /// </summary>
    /// <param name="font">The <see cref="BitmapFont"/> to update.</param>
    /// <param name="resourcePath">The path where texture resources are located.</param>
    internal static void QualifyResourcePaths(BitmapFont font, string resourcePath)
    {
      Page[] pages;

      pages = font.Pages;

      for (int i = 0; i < pages.Length; i++)
      {
        Page page;

        page = pages[i];
        page.FileName = Path.Combine(resourcePath, page.FileName);
        pages[i] = page;
      }

      font.Pages = pages;
    }

    /// <summary>
    /// Splits the specified string using a given delimiter, ignoring any instances of the delimiter as part of a quoted string.
    /// </summary>
    /// <param name="s">The string to split.</param>
    /// <param name="delimiter">The delimiter.</param>
    /// <returns></returns>
    internal static string[] Split(string s, char delimiter)
    {
      string[] results;

      if (s.IndexOf('"') != -1)
      {
        List<string> parts;
        int partStart;

        partStart = -1;
        parts = new List<string>();

        do
        {
          int partEnd;
          int quoteStart;
          int quoteEnd;
          bool hasQuotes;

          quoteStart = s.IndexOf('"', partStart + 1);
          quoteEnd = s.IndexOf('"', quoteStart + 1);
          partEnd = s.IndexOf(delimiter, partStart + 1);

          if (partEnd == -1)
          {
            partEnd = s.Length;
          }

          hasQuotes = quoteStart != -1 && partEnd > quoteStart && partEnd < quoteEnd;
          if (hasQuotes)
          {
            partEnd = s.IndexOf(delimiter, quoteEnd + 1);
          }

          parts.Add(s.Substring(partStart + 1, partEnd - partStart - 1));

          if (hasQuotes)
          {
            partStart = partEnd - 1;
          }

          partStart = s.IndexOf(delimiter, partStart + 1);
        } while (partStart != -1);

        results = parts.ToArray();
      }
      else
      {
        results = s.Split(new char[]
                          {
                            delimiter
                          }, StringSplitOptions.RemoveEmptyEntries);
      }

      return results;
    }

    /// <summary>
    /// Converts the given collection into an array
    /// </summary>
    /// <typeparam name="T">Type of the items in the array</typeparam>
    /// <param name="values">The values.</param>
    /// <returns></returns>
    internal static T[] ToArray<T>(ICollection<T> values)
    {
      T[] result;

      // avoid a forced .NET 3 dependency just for one call to Linq

      result = new T[values.Count];
      values.CopyTo(result, 0);

      return result;
    }

    #endregion Internal Methods
  }
}
